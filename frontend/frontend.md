## 前端缓存架构

### 1 前端缓存哪些东西？
大文件：
 - PDF 文件 Blob 流及完整数据
 用户业务数据：
 - 用户的论文文献库
 - 用户创建的笔记内容
 - AI 历史对话记录
 - 用户自定义添加的大模型列表
 - 自定义系统提示词
 - 用户填写的个人大模型第三方 API Key 信息
 用户配置数据：
 - 登录凭证（如 JWT Token）
 - 高级/敏感功能的临时验证凭据（如 Session 级别的 PIN 码状态）
 - 系统主题设置（深色/浅色模式）
 当前页面信息：
 - 当前选中的默认大模型
 - 当前正在阅读/选中的文档 ID
 - 尚未发送的对话框/笔记输入草稿文本
 - 各侧边栏窗口、弹窗面板的打开/折叠状态

### 2 前端有哪些缓存实体？

磁盘永久存储：
1. IndexedDB：浏览器磁盘
  - 占据磁盘空间，几乎无上限
  - 适合存大文件+大量结构化数据
  - 永久存储，除非清除浏览器数据等
2. LocalStorage：浏览器磁盘
  - 占据磁盘空间，约5MB
  - 以字符串键值对存储
  - 永久存储，除非清除浏览器数据等

内存临时存储：
1. Pinia Store：浏览器运行内存
  - 几十-几百MB
  - 全局响应式，读写极快，刷新页面即丢失
2. SessionStorage：浏览器运行内存
  - 5MB，只能存储字符串
  - 与特定标签页绑定，关闭标签页后消失
3. 组件内状态 (Vue Refs/Reactive)：浏览器运行内存
  - 与特定组件生命周期绑定，组件销毁即释放销毁
  - 用于保存高频变化的 UI 状态（如弹窗开关、输入框内容）
4. Blob URL Cache：浏览器内存
  - 用于 PDF 等大文件的 Blob 流映射（URL.createObjectURL）
  - 刷新即断开，需重新从 IndexedDB/后端加载并生成 URL

### 3 数据管理层架构设计

#### 1. 数据层级与缓存策略

| 数据类别 | 典型实体 | 存储媒介 | 读写逻辑|
| :--- | :--- | :--- | :--- |
| 大文件 | PDF Blob 资源流 + 前端解析资源 | `IndexedDB` (L1)+ `Blob URL` (L2) | UI 层请求 -> 检查 IndexedDB -> 有则直接转换为 Blob URL 展示；无则请求后端下载 -> 存入 IndexedDB -> 转换为 Blob URL。 (需要定时删除) |
| 核心业务关系数据 | 论文元数据列表、笔记、聊天历史、用户自定义提示词和模型列表 | `IndexedDB (L1)` + `Pinia (L2)` |Pinia 作为唯一真相, 加载时从 IndexedDB 水合到 Pinia；修改时，先更新 Pinia (响应式更新UI) -> 异步写入 IndexedDB -> 异步同步到后端 (携带 `last_synced_at`)。 |
| 翻译段落 | 段落翻译结果 | 后端数据库（权威）+ `Pinia`（session 内内存缓存） | 后端接口已实现服务端缓存，同一段落 `force=false` 时直接命中缓存返回；前端 Pinia 仅用于当前 session 内快速重读，面板关闭即释放，刷新后重新从后端拉取。 |
| 敏感/高安全性数据 | 临时 PIN 码验证状态、第三方 API Key | `SessionStorage (L2)` | PIN码状态仅存 SessionStorage；API Key 加密后存储在 LocalStorage 中。 |
| UI/偏好极小状态 | 深色模式、当前选中大模型、当前选中侧边栏 | `LocalStorage (L1)` + `Pinia (L2)` | 同步持久化：每次 Pinia 状态变更，通过 `watch` 同步覆盖 LocalStorage。极小体积，无性能负担。 |
